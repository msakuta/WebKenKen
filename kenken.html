<!DOCTYPE html>
<html lang="en">
	<head>
		<title>WebKenKen</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000000;
				font-family:Monospace;
				font-size:15px;
				text-align:center;

				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

		</style>
	</head>
	<body>
		<h1>WebKenKen</h1>
		Size:
		<select id="sizeSelect">
			<option selected>3</option>
			<option>4</option>
			<option>5</option>
			<option>6</option>
			<option>7</option>
			<option>8</option>
			<option>9</option>
		</select>
		<input type="button" onclick="generateBoard()" value="Create"></input>
		<input type="button" onclick="solve()" value="Solve"></input>
		<input type="button" onclick="hide()" value="Hide"></input>
		<input type="button" onclick="save()" value="Save"></input>
		<input type="button" onclick="load()" value="Load"></input>
		<hr>
		<div id="container"></div>

		<script>
		var container;
		var table;
		var size;
		var board;
		var region;
		var cellElems;
		var operElems;
		var operators;
		var memos;
		var selectedCell = null;
		var selectedCoords = null;
		var messageElem;
		var debugText;

		function iterateCells(func){
			for(var iy = 0; iy < size; iy++){
				for(var ix = 0; ix < size; ix++){
					func(ix, iy);
				}
			}
		}

		function solve(){
			iterateCells(function(ix, iy){
				var valueDiv = document.getElementById('r' + iy + 'c' + ix);
				valueDiv.innerHTML = board[ix + iy * size];
				valueDiv.style.display = 'block';
			});
		}

		function hide(){
			iterateCells(function(ix, iy){
				var valueDiv = document.getElementById('r' + iy + 'c' + ix);
				valueDiv.style.display = 'none';
			});
		}

		function checkAnswer(){
			var correct = true;
			iterateCells(function(ix, iy){
				var valueDiv = document.getElementById('r' + iy + 'c' + ix);
				// String based comparison because valueDiv may contain whitespace
				if(board[ix + iy * size].toString() !== valueDiv.innerHTML)
					correct = false;
			});
			if(correct){
				messageElem.innerHTML = "Congratulations!<br>You've solved the puzzle!";
			}
		}

		window.onload = function(){
			generateBoard();
		}
		
		function createElements(){
			cellElems = new Array(size * size);
			operElems = new Array(size * size);

			// The containers are nested so that the inner container can be easily
			// discarded to recreate the whole game.
			var outerContainer = document.getElementById("container");
			if(container)
				outerContainer.removeChild(container);
			container = document.createElement("div");
			outerContainer.appendChild(container);

			table = document.createElement("div");
			table.style.borderStyle = 'solid';
			table.style.borderWidth = '1px';
			table.style.borderColor = 'red';
			table.style.position = 'relative';
			table.style.left = '50%';
			table.style.width = (size * 4. + 0.1) + 'em';
			table.style.height = (size * 4. + 0.1) + 'em';

			messageElem = document.createElement('div');
			container.appendChild(messageElem);
			messageElem.style.fontFamily = 'Sans-serif';
			messageElem.style.fontSize = '20pt';
			messageElem.style.position = 'relative';
			messageElem.style.color = 'red';

			container.appendChild(table);
			for(var iy = 0; iy < size; iy++){
				for(var ix = 0; ix < size; ix++){
					var cell = document.createElement("div");
					cellElems[ix + iy * size] = cell;
					cell.innerHTML = "";
					//cell.style.backgroundColor = colors[region[ix + iy * size] % 4];
					cell.style.width = '3.5em';
					cell.style.height = '3.5em';
					cell.style.position = 'absolute';
					cell.style.top = (4.0 * iy + 0.2) + 'em';
					cell.style.left = (4.0 * ix + 0.2) + 'em';
					cell.style.verticalAlign = 'middle';
					cell.onclick = function(){
						selectCell(this);
					}
					table.appendChild(cell);

					var operElem = document.createElement('div');
					operElem.style.position = 'absolute';
					operElem.style.top = '0px';
					cell.appendChild(operElem);
					operElems[ix + iy * size] = operElem;

					var valueDiv = document.createElement("div");
					valueDiv.id = 'r' + iy + 'c' + ix;
					valueDiv.style.fontSize = '30px';
					valueDiv.style.position = 'absolute';
					valueDiv.style.top = '50%';
					valueDiv.style.width = '100%';
					valueDiv.style.textAlign = 'center';
					valueDiv.innerHTML = '&nbsp;';
					cell.appendChild(valueDiv);
					var r = valueDiv.getBoundingClientRect();
					valueDiv.style.marginTop = (-r.height / 2) + 'px';
					valueDiv.style.display = 'none';

					var memoElem = document.createElement("div");
					memoElem.id = 'memo_r' + iy + 'c' + ix;
					memoElem.style.fontSize = '12px';
					memoElem.style.position = 'relative';
					memoElem.style.top = '100%';
					memoElem.style.marginTop = '-1em';
					memoElem.innerHTML = '';
					var currentSet = memos[ix + iy * size] || [];
					for(var j = 0; j < currentSet.length; j++)
						memoElem.innerHTML += currentSet[j];
					cell.appendChild(memoElem);
				}
			}
			// Set the margin after contents are initialized
			table.style.marginLeft = (-table.getBoundingClientRect().width / 2) + 'px';

			var answers = document.createElement('div');
			container.appendChild(answers);
			answers.style.fontSize = '25px';
			answers.style.padding = '10px';
			answers.innerHTML = 'Ans: ';

			function addAnswer(str){
				var a = document.createElement('span');
				answers.appendChild(a);
				a.innerHTML = str;
				a.style.marginRight = '10px';
				a.style.border = '1px solid blue';
				a.style.padding = '5px';
				a.onclick = function(){
					if(selectedCoords){
						var valueDiv = document.getElementById('r' + selectedCoords[1] + 'c' + selectedCoords[0]);
						valueDiv.style.display = 'block';
						valueDiv.innerHTML = this.innerHTML;
						checkAnswer();
					}
				};
			}

			for(var i = 0; i < size; i++){
				addAnswer((i + 1).toString());
			}
			addAnswer('&nbsp;');

			var memoContainer = document.createElement('div');
			container.appendChild(memoContainer);
			memoContainer.style.fontSize = '15px';
			memoContainer.style.padding = '10px';
			memoContainer.innerHTML = 'Memo: ';
			for(var i = 0; i < size; i++){
				var a = document.createElement('span');
				memoContainer.appendChild(a);
				a.innerHTML = (i + 1).toString();
				a.style.marginRight = '10px';
				a.style.border = '1px solid blue';
				a.style.padding = '5px';
				a.onclick = function(){
					if(selectedCoords){
						var memoElem = document.getElementById('memo_r' + selectedCoords[1] + 'c' + selectedCoords[0]);
						memoElem.style.display = 'block';
						var currentSet = memos[selectedCoords[0] + selectedCoords[1] * size] || [];
						var idx = currentSet.indexOf(this.innerHTML);
						if(0 <= idx)
							currentSet.splice(idx, 1);
						else {
							currentSet.push(this.innerHTML);
							currentSet.sort();
						}
						memos[selectedCoords[0] + selectedCoords[1] * size] = currentSet;
						memoElem.innerHTML = '';
						for(var j = 0; j < currentSet.length; j++)
							memoElem.innerHTML += currentSet[j];
					}
				}
			}

			debugText = document.createElement('div');
			container.appendChild(debugText);
		}

		function selectCell(sel){
			selectedCell = sel;
			iterateCells(function(ix, iy){
				if(cellElems[ix + iy * size] === sel){
					cellElems[ix + iy * size].style.border = '2px blue solid';
					selectedCoords = [ix, iy];
				}
				else
					cellElems[ix + iy * size].style.border = '1px black solid';
			})
		}

		function paintCells(region){
			var colors = [
				'#aaa',
				'#faa',
				'#afa',
				'#aaf',
				'#ffa',
				'#aff',
				'#faf',
				'#f00',
				'#0c0',
				'#c0c',
				'#0ff',
				'#07f',
				'#0f7',
				'#f40',
				'#7f0',
				'#f07',
				'#70f',
				'#fff',
			];

			for(var y = 0; y < size; y++){
				for(var x = 0; x < size; x++){
					cellElems[x + y * size].style.backgroundColor = colors[region[x + y * size] % colors.length];
				}
			}
		}

		function setOperatorElems(region){
			// Clear the operator indicator before assigning one because
			// there could be old text from rejected tries.
			for(var i = 0; i < size * size; i++){
				var operElem = operElems[i];
				operElem.innerHTML = '';
			}
			for(var i = 0; i < operators.length; i++){
				var top, left;
				var first = true;
				iterateCells(function(ix, iy){
					if(region[ix + iy * size] === i + 1){
						if(first){
							top = iy;
							left = ix;
						}
						first = false;
					}
				});
				var operElem = operElems[left + top * size];
				operElem.innerHTML = operators[i].product + operators[i].oper;
				operElem.style.position = 'absolute';
				operElem.style.top = '0px';
			}
		}

		function generateBoard(){
			var sizeStr = document.getElementById("sizeSelect").value;
			size = parseInt(sizeStr);
			board = new Array(size * size);
			region = new Array(size * size);
			memos = new Array(size * size);
			operators = [];

			var latinSquareTries = 0;

			function genLatinSquare(){
				for(var iy = 0; iy < size; iy++){
					for(var tries = 0; tries < 1000; tries++){
						latinSquareTries++;
						if((function(){
							var next = board.slice(0);
							// First, build an array of all available numbers for a row.
							// We will randomly pick and delete from this array to enumerate permutation.
							var avail = [];
							for(var i = 0; i < size; i++)
								avail.push(i+1);
							for(var ix = 0; ix < size; ix++){
								// Create a clone of available numbers array and delete numbers already used in column.
								// This will greatly reduce the chance of invalid permutation, but it's not like
								// it will never happen, so we still need to retry if permutation fails.
								var vavail = avail.slice(0);
								for(var j = 0; j < iy; j++){
									var vidx = vavail.indexOf(board[ix + j * size]);
									if(0 <= vidx)
										vavail.splice(vidx, 1);
								}
								// There's a possibility of using up all available numbers, in which case we should
								// retry for this row.
								// If we'd be sure to check every possible permutations, rather than retry with exactly
								// the same conditions and new random numbers, we could use recursive calls to
								// track all paths like the labeling algorithm, but it seems unnecessary around size 6.
								if(vavail.length === 0)
									return false;
								var idx = Math.floor(Math.random() * vavail.length);
								if(idx < 0)
									return false;
								next[ix + iy * size] = vavail[idx];
								// The original available numbers array should always contain numbers picked from reduced array.
								avail.splice(avail.indexOf(vavail[idx]), 1);
							}
							board = next;
							return true;
						})())
							break;
					}
				}
			}

			var allTries = 0;
			var solveTries = 0;

			function checkSolvability(region){
				function sameVector(a,b){
					for(var i = 0; i < a.length; i++)
						if(a[i] !== b[i])
							return false;
					return true;
				}
				function columnVector(region, x){
					var ret = [];
					for(var i = 0; i < size; i++)
						ret.push(region[x + i * size]);
					return ret;
				}

				// Check if the region definition has a duplicate row or column,
				// in which case it is clear that the problem cannot be solved
				// with single answer.  You could swap these rows or columns to
				// obtain another solution.
				for(var iy = 0; iy < size; iy++){
					var row = region.slice(iy * size, (iy + 1) * size);
					for(var jy = iy + 1; jy < size; jy++)
						if(sameVector(row, region.slice(jy * size, (jy + 1) * size)))
							return false;
				}
				for(var ix = 0; ix < size; ix++){
					var col = columnVector(region, ix);
					for(var jx = ix + 1; jx < size; jx++)
						if(sameVector(col, columnVector(region, jx)))
							return false;
				}

				genLatinSquare();
				setOperators(region);

				// Assigning true to this variable enables the debugger to let you see
				// the process of reducing solution possibilities by step execution.
				var visualizeSolveProcess = false;

				if(visualizeSolveProcess)
					setOperatorElems(region);

				/// The debug function to visualize the process.
				function showField(x, y){
					if(!visualizeSolveProcess)
						return;
					var memoElem = document.getElementById('memo_r' + y + 'c' + x);
					memoElem.style.display = 'block';
					memoElem.innerHTML = '';
					for(var i = 0; i < size; i++)
						if(field[x + y * size] & (1 << i))
							memoElem.innerHTML += (i + 1).toString();
				}

				// 'field' is an array of bitfields for possibilities.
				// Using bitfields rather than arrays enables fast operations
				// (especially cloning) but limits maximum size.
				// Since JavaScript bitwise operators works with 32 bits,
				// we're safe to use it as a bitfield for puzzle sizes up to 9.
				var field = new Array(size * size);
				for(var iy = 0; iy < size; iy++){
					for(var ix = 0; ix < size; ix++){
						var currentSet = 0;
						for(var i = 0; i < size; i++)
							currentSet |= 1 << i;
						field[ix + iy * size] = currentSet;
						showField(ix, iy);
					}
				}

				// From this point, the codes tries to find an answer by reducing
				// possibilities in each cells.
				// We do not fully trace all possible combinations, because the
				// number of combinations are too large to enumerate
				// (10^9 for a size 6 latin square, according to
				//  https://en.wikipedia.org/wiki/Latin_square ),
				// and it's not the method humans normally use.
				// We only check all combinations in operator partitions, which
				// humans can do.
				for(var n = 0; n < 10; n++){
					var prevField = field.slice(0);

					for(var i = 0; i < operators.length; i++){
						var cellPos = [];
						iterateCells(function(ix, iy){
							if(region[ix + iy * size] === i + 1){
								cellPos.push([ix, iy]);
							}
						});
						if(cellPos.length === 0)
							break;
						if(operators[i].oper == '*'){
							for(var j = 0; j < size; j++){
								if(operators[i].product % (j + 1) !== 0){
									for(var k = 0; k < cellPos.length; k++){
										var ix = cellPos[k][0];
										var iy = cellPos[k][1];
										field[ix + iy * size] &= ~(1 << j);
										showField(ix, iy);
									}
								}
							}
						}
						if(operators[i].oper == '/'){
							var jx = cellPos[0][0];
							var jy = cellPos[0][1];
							var jfield = field[jx + jy * size];
							var jvalid = 0;
							var kx = cellPos[1][0];
							var ky = cellPos[1][1];
							var kfield = field[kx + ky * size];
							var kvalid = 0;
							for(var j = 0; j < size; j++){
								if(!(jfield & (1 << j)))
									continue;
								for(var k = 0; k < size; k++){
									if(!(kfield & (1 << k)))
										continue;
									var jv = j + 1;
									var kv = k + 1;
									if(jv < kv){
										if(kv / jv === operators[i].product){
											jvalid |= 1 << j;
											kvalid |= 1 << k;
										}
									}
									else{
										if(jv / kv === operators[i].product){
											jvalid |= 1 << j;
											kvalid |= 1 << k;
										}
									}
								}
							}

							jfield &= jvalid;
							field[jx + jy * size] = jfield;
							showField(jx, jy);
							kfield &= kvalid;
							field[kx + ky * size] = kfield;
							showField(kx, ky);
						}
						if(operators[i].oper == '-'){
							var jx = cellPos[0][0];
							var jy = cellPos[0][1];
							var jfield = field[jx + jy * size];
							var jvalid = 0;
							var kx = cellPos[1][0];
							var ky = cellPos[1][1];
							var kfield = field[kx + ky * size];
							var kvalid = 0;
							for(var j = 0; j < size; j++){
								if(!(jfield & (1 << j)))
									continue;
								for(var k = 0; k < size; k++){
									if(!(kfield & (1 << k)))
										continue;
									var jv = j + 1;
									var kv = k + 1;
									if(jv < kv){
										if(kv - jv === operators[i].product){
											jvalid |= 1 << j;
											kvalid |= 1 << k;
										}
									}
									else{
										if(jv - kv === operators[i].product){
											jvalid |= 1 << j;
											kvalid |= 1 << k;
										}
									}
								}
							}

							jfield &= jvalid;
							field[jx + jy * size] = jfield;
							showField(jx, jy);
							kfield &= kvalid;
							field[kx + ky * size] = kfield;
							showField(kx, ky);
						}
						if(operators[i].oper === '+' || operators[i].oper === '*'){
							// Recursively checks possible combinations for addition
							// or multiplcation operator
							function checkAddOper(field, j, k, sum, stop){
								solveTries++;
								var next = field.slice(0);
								var jx = cellPos[j][0];
								var jy = cellPos[j][1];
								if(!(next[jx + jy * size] & (1 << k)))
									return false;
								if(operators[i].oper === '+')
									sum += k + 1;
								else
									sum *= k + 1;
								// Even before we add all cells, we are sure that
								// sum greater than the operator's value is not possible.
								if(operators[i].product < sum)
									return false;
								next[jx + jy * size] = (1 << k);
								for(var l = 0; l < size; l++){
									if(l !== jx)
										next[l + jy * size] &= ~(1 << k);
									if(l !== jy)
										next[jx + l * size] &= ~(1 << k);
								}
								j = (j + 1) % cellPos.length;
								if(j === stop)
									return sum === operators[i].product;
								for(var l = 0; l < size; l++){
									var ret = checkAddOper(next, j, l, sum, stop);
									if(ret)
										return true;
								}
								return false;
							}

							for(var j = 0; j < cellPos.length; j++){
								for(var l = 0; l < size; l++){
									var ret = checkAddOper(field, j, l, operators[i].oper === '+' ? 0 : 1, j);
									var jx = cellPos[j][0];
									var jy = cellPos[j][1];
									if(!ret)
										field[jx + jy * size] &= ~(1 << l);
									showField(jx, jy);
								}
							}
						}
					}

					function checkRowCell(ix, iy, k, field, axis, stop){
						solveTries++;
						var next = field.slice(0);
						if(!(next[ix + iy * size] & (1 << k)))
							return false;
						next[ix + iy * size] = (1 << k);
						for(var l = 0; l < size; l++){
							if(l !== ix){
								next[l + iy * size] &= ~(1 << k);
								if(next[l + iy * size] === 0)
									return false;
							}
							if(l !== iy){
								next[ix + l * size] &= ~(1 << k);
								if(next[ix + l * size] === 0)
									return false;
							}
						}
						if(axis === 0)
							ix = (ix + 1) % size;
						else
							iy = (iy + 1) % size;
						if((axis === 0 ? ix : iy) !== stop){
							for(var l = 0; l < size; l++)
								if(checkRowCell(ix, iy, l, next, axis, stop))
									return true;
							return false;
						}
						else {
							return true;
						}
					}

					for(var iy = 0; iy < size; iy++){
						for(var ix = 0; ix < size; ix++){
							for(var k = 0; k < size; k++){
								var ret = checkRowCell(ix, iy, k, field, 0, ix);
								if(!ret){
									field[ix + iy * size] &= ~(1 << k);
									showField(ix, iy);
								}
							}
						}
					}

					for(var ix = 0; ix < size; ix++){
						for(var iy = 0; iy < size; iy++){
							for(var k = 0; k < size; k++){
								var ret = checkRowCell(ix, iy, k, field, 1, iy);
								if(!ret){
									field[ix + iy * size] &= ~(1 << k);
									showField(ix, iy);
								}
							}
						}
					}
					if(sameVector(prevField, field))
						break;
				}

				for(var i = 0; i < size * size; i++){
					var count = 0;
					for(var k = 0; k < size; k++)
						if(field[i] & (1 << k))
							count++;
					if(1 < count)
						return false;
				}
				return true;
			}

			function growCells(type, region){
				function growCellSingle(x, y, type, region, cells){
					allTries++;
					var next = region.slice(0);
					var avail = [];
					if(2 <= cells){
						avail.push({func: function(){
							var ret = growCells(type, region);
							if(ret)
								return ret;
							paintCells(region);
						}, data: null,
						weight: 3}); // Prioritize small regions by weighting option for creating new regions
					}
					next[x + y * size] = type;
					if(cells < 3){
						var deltax = [-1, 0, 1, 0];
						var deltay = [0, -1, 0, 1];
						for(var i = 0; i < 4; i++){
							var newx = x + deltax[i];
							var newy = y + deltay[i];
							if(newx < 0 || size <= newx || newy < 0 || size <= newy)
								continue;
							if(region[newx + newy * size])
								continue;
							avail.push({func: function(data){
								paintCells(next);
								return growCellSingle(data[0], data[1], type, next, cells + 1);
								},
								data: [newx, newy],
								weight: 1});
						}
					}

					// Backtrack all available options recursively
					while(avail.length){
						// Options have weights, so we first measure total weight
						var allWeight = 0;
						for(var j = 0; j < avail.length; j++)
							allWeight += avail[j].weight;
						// Obtain value for selecting an option
						var val = Math.random() * allWeight;
						// Accumulate weights and find the corresponding option
						allWeight = 0;
						for(var j = 0; j < avail.length; j++){
							allWeight += avail[j].weight;
							if(val < allWeight){
								ret = avail[j].func(avail[j].data);
								if(ret)
									return ret;
								avail.splice(j, 1);
								break;
							}
						}
					}
					// At least 2 cells are required
					if(cells < 1)
						return null;
					return growCells(type, next);
				}

				function growCellTry(type, region){

					for(var iy = 0; iy < size; iy++){
						for(var ix = 0; ix < size; ix++){
							if(region[ix + iy * size] === 0){
								return growCellSingle(ix, iy, ++type, region, 0);
							}
						}
					}
					if(iy == size)
						return region;
					else
						return false;
				}

				var numTries = 1;
				for(var tries = 0; tries < numTries; tries++){
					var ret = growCellTry(type, region);
					if(ret)
						return ret;
				}
				// If all tries fail, return null
				return null;
			}

			for(var iy = 0; iy < size; iy++){
				for(var ix = 0; ix < size; ix++){
					region[ix + iy * size] = 0;
				}
			}

			createElements();

			selectCell(null);

			function setOperators(region){
				operators = [];
				for(var i = 1; i < 100; i++){
					var cellValues = [];
					iterateCells(function(ix, iy){
						if(region[ix + iy * size] === i){
							cellValues.push(board[ix + iy * size]);
						}
					});
					if(cellValues.length === 0)
						break;
					var avail = ['*', '+'];
					if(cellValues.length === 2)
						avail.push('-');
					// If numbers are not dividable to each other, we can't use it for division operator
					if(cellValues.length === 2 && (cellValues[0] % cellValues[1] === 0 || cellValues[1] % cellValues[0] === 0))
						avail.push('/');
					var index = Math.floor(Math.random() * avail.length);
					var oper = avail[index];
					var product;
					if(oper === '+'){
						product = 0;
						for(var j = 0; j < cellValues.length; j++)
							product += cellValues[j];
					}
					else if(oper === '*'){
						product = 1;
						for(var j = 0; j < cellValues.length; j++)
							product *= cellValues[j];
					}
					else if(oper === '-'){
						product = Math.abs(cellValues[1] - cellValues[0]);
					}
					else if(oper === '/'){
						product = cellValues[0] < cellValues[1] ? cellValues[1] / cellValues[0] : cellValues[0] / cellValues[1];
					}
					operators.push({
						oper: oper,
						product: product,
					})
				}
			}

			for(var tries = 0; tries < 100; tries++){
				var ret = growCells(0, region);
				if(!ret)
					continue;
				if(!checkSolvability(ret))
					continue;
				region = ret;
				paintCells(region);
				setOperatorElems(region);
				break;
			}

			debugText.innerHTML = 'labelTries: ' + allTries.toString()
				+ ', latinSquareTries: ' + latinSquareTries.toString()
				+ ', solveTries: ' + solveTries;
		};

		function getSaveData(){
			var storage = localStorage.getItem('WebKenKen');
			if(!storage)
				return null;
			content = JSON.parse(storage);
			if(content['save'] && content['save']['save'])
				return content['save']['save'];
			else
				return null;
		}

		function save(){
			if(!window.localStorage || !window.JSON){
				alert('Your browser cannot save the game progress.');
				return;
			}
			if(getSaveData() && !confirm('There is already a saved progress. OK to overwrite?'))
				return;
			var saveData = {};
			saveData.size = size;
			saveData.answer = [];
			iterateCells(function(ix, iy){
				var valueDiv = document.getElementById('r' + iy + 'c' + ix);
				saveData.answer[ix + iy * size] = valueDiv.innerHTML;
			});
			saveData.board = board;
			saveData.region = region;
			saveData.operators = operators;
			saveData.memos = memos;
			localStorage.setItem('WebKenKen', JSON.stringify({save: {save: saveData}}));
		}

		function load(){
			if(!window.localStorage || !window.JSON){
				alert('Your browser cannot save the game progress.');
				return;
			}
			var saveData = getSaveData();
			if(!saveData){
				alert('There is no saved game');
				return;
			}
			size = saveData.size;
			board = saveData.board;
			region = saveData.region;
			operators = saveData.operators;
			memos = saveData.memos;
			createElements();
			paintCells(region);
			selectCell(null);
			setOperatorElems(region);
			iterateCells(function(ix, iy){
				var valueDiv = document.getElementById('r' + iy + 'c' + ix);
				valueDiv.innerHTML = saveData.answer[ix + iy * size];
				valueDiv.style.display = 'block';
			});
			debugText.innerHTML = 'loaded ' + localStorage['WebKenKen'].length + ' bytes';
		}

		</script>

	</body>
</html>
